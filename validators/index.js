var hashObj = require('object-hash');

class ByzantineError extends Error {
	constructor(m) {
		super(m);
		this.name = "ByzantineError"
	}
}

class Validator {
	constructor(name, weight, startingPoint) {
		this.name = name;
		this.weight = weight;

		this.msgHashTable = {};
		this.lastMsgHashes = {};
		this.messageSequences = {};
		this.isByzantine = {};

		/*
		 * Add the starting point message to the hash table
		 * and also record it as the latest message from this
		 * sender.
		 */
		const msg = {
			sender: this.name,
			weight: this.weight,
			estimate: startingPoint,
			justification: [],
		};
		const msgHash = this.addToHashTable(msg, this.msgHashTable);
		this.lastMsgHashes[this.name] = msgHash;
	}

	flagAsByzantine(sender) {
		this.isByzantine[sender] = true;
	}

	getEstimate() {
		const msgs = Object.keys(this.lastMsgHashes).map(m => {
			return this.msgHashTable[this.lastMsgHashes[m]]
		});
		const totals = msgs.reduce((totals, msg) => {
			totals[msg.estimate] += msg.weight;
			return totals;
		}, [0, 0]);
		const estimate = totals[1] > totals[0] ? 1 : 0;
		const weight = (totals[0] + totals[1]) / totals[estimate];

		/*
		 * As per CasperTFG paper:
		 *
		 * E(M) = 0 if Score(0, M) > Score(1, M)
		 * E(M) = 1 if Score(1, M) > Score(0, M)
		 * E(M) = 0 if Score(1, M) = Score(0, M)
		 */
		return {
			estimate,
			weight
		}
	}

	generateMessage() {
		/*
		 * Get the latest message for each sender
		 */
		const latestMsgs = Object.keys(this.lastMsgHashes)
			.map(s => {
				return this.decompressFromHashTable(
					this.lastMsgHashes[s], 
					this.msgHashTable
				);
			});
		/*
		 * If there is only one latest message and it's ours, send it.
		 */
		if(latestMsgs.length === 1 && latestMsgs[0].sender === this.name) {
			return latestMsgs[0];
		}
		/*
		 * If we have messages from other senders, we need to build
		 * an estimate
		 */
		const msg = {
			sender: this.name,
			weight: this.weight,
			estimate: this.getEstimate(latestMsgs).estimate,
			justification: latestMsgs,
		}
		const msgHash = this.addToHashTable(msg, this.msgHashTable);
		this.lastMsgHashes[this.name] = msgHash;
		return msg;
	}

	lastMsgHashFrom(who) {
		return this.lastMsgHashes[who];
	}

	getDependencies(hash, table) {
		const msg = table[hash];
		const deps = msg.justification;
		return msg.justification.reduce((acc, j) => {
			acc = acc.concat(this.getDependencies(j, table));
			return acc;
		}, deps);
		return deps;
	}

	addToHashTable(msg, table) {
		let hashedMsg = Object.assign({}, msg);
		hashedMsg.justification = msg.justification.map(j => {
			return this.addToHashTable(j, table)
		});
		const msgHash = hashObj(hashedMsg);
		table[msgHash] = hashedMsg;
		return msgHash;
	}

	decompressFromHashTable(hash, table) {
		let msg = Object.assign({}, table[hash]);
		msg.justification = msg.justification.map(j => {
			return this.decompressFromHashTable(j, table);
		});
		return msg;
	}

	messageHasDuplicateVotes(msg) {
		const senders = {};
		let hasDupes = false;
		msg.justification.forEach(j => {
			hasDupes = (hasDupes 
				|| senders[j.sender] 
				|| this.messageHasDuplicateVotes(j));
			senders[j.sender] = true;
		});
		if(hasDupes) { return true; }
		
		return false;
	}

	getMessageSequence(who) {
		return this.messageSequences[who] ? this.messageSequences[who] : []
	}
	
	setMessageSequence(who, seqs) {
		this.messageSequences[who] = seqs;
	}

	isMessageKnown(hash) {
		return this.msgHashTable[hash] !== undefined;
	}

	verifyMessage(msg) {
		if(this.messageHasDuplicateVotes(msg)) {
			this.flagAsByzantine(msg.sender);
			throw new ByzantineError(
				"There were multiple messages from the same sender in " +
				"the justification of the message."
			);
		}

		const table = {};
		const msgHash = this.addToHashTable(msg, table);

		/*
		 * For each sender, build a linear history of messages, as defined
		 * by only this message.
		 */
		const seqs = [];
		const makeSeqs = function(hash, sender) {
			seqs.unshift(hash);
			const nextDep = table[hash].justification.find(h => {
				return table[h].sender === sender;
			});
			if(nextDep) { 
				makeSeqs(nextDep, sender); 
			}
			else if (nextDep === undefined && table[hash].justification.length > 0) {
				this.flagAsByzantine(msg.sender);
				throw new ByzantineError(
					"The sender omitted their previous latest message  " +
					"from the justification."
				)
			}
		}.bind(this);
		makeSeqs(msgHash, msg.sender);
		

		/*
		 * Compare the history generated by this new message and ensure
		 * that it does not conflict with our previously known history
		 * from this sender.
		 */
		const knownSeqs = this.getMessageSequence(msg.sender);
		// If we don't have a message sequence for this validator,
		// accept this sequence as the truth.
		if(knownSeqs.length === 0) {
			this.setMessageSequence(msg.sender, seqs);
			return;
		}
		const index = knownSeqs.indexOf(seqs[0]);
		// If the very first message from a sender in this message history
		// is not known to us, then it means they have invented two different
		// initial messages and are therefore bzyantine.
		if(index < 0) { 
			this.flagAsByzantine(msg.sender);
			throw new ByzantineError(
				"The initial message referenced by the sender was not the " +
				"previously known initial message."
			); 
		}
		// Start checking the two histories for a fork (and also extend our
		// currently known sequence if there are no forks)
		for(var i = 0; i < seqs.length; i++) {
			const knownSeqsIndex = i + index;
			if(knownSeqsIndex >= knownSeqs.length) {
				knownSeqs.push(seqs[i]);
			}
			else if(seqs[i] !== knownSeqs[knownSeqsIndex]) {
				this.flagAsByzantine(msg.sender);
				throw new ByzantineError("There was a fork in the message history.")
			}
		}
	}

	verifyAndStore(msg) {
		const table = {};
		const msgHash = this.addToHashTable(msg, table);

		const recurse = function(hash) {
			table[hash].justification.forEach(h => recurse(h));
			// If we don't already have this message, then attempt to verify
			// and store it if it passes.
			if(!this.isMessageKnown(hash)){
				this.verifyMessage(this.decompressFromHashTable(hash, table));
				// We will proceed to the next line only if the above call didn't
				// throw and the message is therefore valid.
				this.msgHashTable[hash] = table[hash];
			}
		}.bind(this);
		recurse(msgHash);
	}

	parseMessage(msg) {
		// TODO: check that the estimate of the message checks out
		const table = {};
		const storeMsg = () => Object.assign(this.msgHashTable, table);
		const msgHash = this.addToHashTable(msg, table);
		const latestMsgHash = this.lastMsgHashes[msg.sender];
		
		try {
			//this.verifyMessage(msg);
			this.verifyAndStore(msg);
		}	
		catch(e) {
			if(e.name === "ByzantineError") {
				this.flagAsByzantine(msg.sender);
			} else {
				throw e;
			}
			return e;
		}

		/*
		 * If there were no previous latest messages, this is necessarily
		 * the latest.
		 */
		if(latestMsgHash === undefined) {
			storeMsg();
			this.lastMsgHashes[msg.sender] = msgHash;
			return;
		} 

		/*
		 * If the current latest message is a dependency of the latest
		 * message, then this new message should become the latest
		 * message.
		 */
		const msgDeps = this.getDependencies(msgHash, table)
		if(msgDeps.indexOf(latestMsgHash) >= 0) {
			storeMsg();
			this.lastMsgHashes[msg.sender] = msgHash;
			return;
		}

		/*
		 * If the new message is a dependency of the current latest 
		 * message, then this is a repeated message
		 */
		const latestMsgDeps = this.getDependencies(
			latestMsgHash, 
			this.msgHashTable
		);
		if(latestMsgDeps.indexOf(msgHash) >= 0) {
			// this is a repeat message. nothing to do.
			return;
		}

		/*
		 * If this is the same as the latest message, ignore it
		 */
		if(msgHash === this.lastMsgHashes[msg.sender]) {
			return;
		}

		throw new Error("Reached an unexpected condition when parsing message.")
	}
}
module.exports.Validator = Validator;
